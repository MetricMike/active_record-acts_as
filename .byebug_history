exit
acting_as?
exit
acting_as
self
selacting_f
self.class
class
name
acting_as_reflection
exit
table_name
self.arel_table
self
arel_table.name
arel_table
klass._reflections.keys
exit
klass._reflections.keys
klass._reflections
klass
klass._reflect_on_association(table_name)
table_name
klass
exit
_reflections['product']
reflections['product']
association
edit
help
reflections.keys
reflections[association.to_s]
association
_reflections
step
klass
exit
step
super.reverse_merge acting_as_model._reflections
acting_as_model._reflections
acting_as_model
super
exit
n
step
self
n
arel_table
n
exit
ActsAs::Relation
ActAs::Relation
ActAs
ActAs::Relation
ActAs.constants
exit
next
ActAs.constants
exit
Acexit
ActAs.constants
ActAs
exit
continue
step
ActsAs::ReflectionsWithActAs
exit
ActsAs::ReflectionsWithActAs
ActsAs.constants
ActsAs.instance_methods
ActsAs.intance_methods
ActsAs::ReflactionsWithActAs
ActsAs::Relation
ActsAs.included_modules
ActsAs.inspect
ActsAs.modules
ActsAs
exit
@_reflections_acts_as_cache
self.class
exit
_reflections["products"]
association.to_s
_reflections
step
pen.acting_as
klass
exit
up
step
table
tablr
table.associated_table 'pens'
table.associated_table 'pens
table
self.class
association_name
self
up
help
back
klass
table_name
step
value
vale
step
arel_table
step
as
step
klass._reflect_on_association(table_name)
klass
exit
n
step
self.class._reflect_on_association(name)
step
self.class._reflect_on_association(name)
self.class
self
 association_instance_get(name)
name
 association_instance_get(name)
association.nil?
association
step
value
target
step
n 
n
klass._reflect_on_association(association_name)
klass.reflect_on_association assklass._reflect_on_association(association_name)klass._reflect_on_association(association_name)
association_name
klass.reflect_on_association
klass
n
value
column_name
coumn_name
n
step
n
exit
next
value
column
n
 klass._reflect_on_association(:actable)
 klass._reflect_on_association(association_name)
association_name
klass
exit
n
self
n
s
step
klass._reflect_on_association(inverse_name)
klass
reflection
continue
next
exit
step
exit
exitr
Client
exit
Client
exit
Client
User
exit
c = Client.Clientfirst
c = Client.first
exit
next
continue
LinkAd.where ad_group_id: 1
LinkAd.where
LinkAd
exit
Ad
exit
Rails.version < "5.0"
Rails.version z "5.0"
Rails.version > "5.0"
Rails.version
RAILS_VERSION
exit
c.acting_as
c.actable
c = Client.first
c = Client.firs
exit
FactoryGirl
exit
([1,2,3].tap { |o| puts o.class })
([1,2,3].tap { |o| puts o.join('') })
([1,2,3].tap { |o| o })
([1,2,3].tap { |o| o.replace o * 2 })
([1,2,3].tap { |o| o = o * 2 })
([1,2,3].tap { |o| puts o })
([a,b,c].tap { |o| puts o }).chars
("abc".tap { |o| puts o }).chars
("abc".tap { |o| o = "x" }).chars
("abc".tap { |o| o << "x" }).chars
("abc".tap { |o| o = "x" }).chars
"abc".tap { |o| o = "x" }
exit
%r{a}
exit
LinkAd
exit
User
exit
User
exit
end
x.report("intersection:") { ss arr1, arr2 }
x.report("ruby all:") { rall arr1, arr2 }
Benchmark.bmbm do |x|
end
x.report("intersection:") { ss arr1, arr2 }
x.report("ruby all:") { rall arr1, arr2 }
Benchmark.bm(7) do |x|
end
x.report("intersection:") { ss arr1, arr2 }
x.report("ruby all:") { rall arr1, arr2 }
Benchmark.bm(100000) do |x|
include Benchmark
end
x.report("ruby all:") { rall arr1, arr2 }
x.report("intersection:") { ss arr1, arr2 }
Benchmark.bm(100000) do |x|
end
x.report("intersection:") { ss arr1, arr2 }
x.report("ruby all:") { rall arr1, arr2 }
Benchmark.bm(100000) do |x|
end
x.report("intersection:") { ss arr1, arr2 }
x.report("ruby all:") { rall arr1, arr2 }
Benchmark.bm(7) do |x|
require 'benchmark'
ss(arr1,%w(a b c d))
ss(arr1,%w(a b c))
ss(arr1,%w(a n c))
end
(arr1 & arr2) == arr2
def ss(arr1,arr2)
def ss(arr1,%w(a n c))
end
(arr1 & arr2) == arr2
def ss(arr1,arr2)
